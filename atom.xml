<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Entist Dev</title>
  
  <subtitle>개발 아닌 개발 하는 백수라이프</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-18T07:54:05.009Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>AidenJLee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>프로그래머를 위한 간결한 코드 작성 가이드</title>
    <link href="http://yoursite.com/2017/12/18/LessCodeAndLessBugs/"/>
    <id>http://yoursite.com/2017/12/18/LessCodeAndLessBugs/</id>
    <published>2017-12-18T03:28:50.000Z</published>
    <updated>2017-12-18T07:54:05.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Less-code-Less-bugs"><a href="#Less-code-Less-bugs" class="headerlink" title="Less code, Less bugs"></a>Less code, Less bugs</h1><p> ‘가장 좋은 코드는 아무것도 없는 코드다’</p><p> 코드를 적게쓰는건 대부분의 경우에서 좋은 결과를 가져온다. 그렇다면 적은 코드를 만들어 내려면 어떻게 해야 할까? 답은 간단하다. 작성하는 코드는 줄이고 반복하는 코드는 재사용하는 것이다. 이것은 이전에 패턴이라고 불리우던 해결방법을 활용하는 것이다. 패턴도 좋지만 프로그램의 한부분을 라이브러리를 통해 관리하게 하는것은 어떠한가? 나쁘지 않은 방법이다. 코드의 일부를 위임하는 방식으로 프로그래밍을 해보자. [주:1]</p><p>​     이제 남은 문제는 어느부분을 위임하여 처리할 것인가에 대한 정의가 필요하다. 당신이라면 어느 부분을 위임할 것인가?</p><h2 id="관점-분리하기"><a href="#관점-분리하기" class="headerlink" title="관점 분리하기"></a>관점 분리하기</h2><p> 프로그램적 사고는 문제를 정의하고 문제를 해결하는 방식을 말하며,  프로그램은 입력을 출력으로 변환하는 것이다. 문제를 정의 하는 과정에서 위임할 부분을 분리 할 수 있을것이다. 문제를 새로운 관점에서 바라보자. 기존에는 단계별로 나누어서 서로 어떤 부분이 의존관계에 있고 어떤 과정으로 연결되어 처리할지를 고민 했다면 지금부터는 각각의 구성요소가 무엇을 뜻하는지 개념적인 모습으로 선언하고 서로간에 합성을 통해 문제를 해결해보자. 여기에서 의존관계는 이벤트 기반으며 입력에 반응하여 동작하는 데이터의 흐름으로 동시적으로 처리하거나 다른곳에서 처리하자.</p><p> 관점을 다르게 바라본다는 게 어떤의미인지 예시를 통해 알아보자.</p><h3 id="햄버거-만들기"><a href="#햄버거-만들기" class="headerlink" title="햄버거 만들기"></a>햄버거 만들기</h3><p> 햄버거를 만드는 방법을 인터넷 백과에서 가져왔다.</p><h3 id="햄버거-요리법-요리과정"><a href="#햄버거-요리법-요리과정" class="headerlink" title="햄버거 요리법 : 요리과정"></a>햄버거 요리법 : 요리과정</h3><p><a href="http://terms.naver.com/imageDetail.nhn?docId=1988021&amp;imageUrl=http%3A%2F%2Fdbscthumb.phinf.naver.net%2F2799_000_1%2F20131126144005137_M7LXWMRYA.jpg%2F2_i3.jpg%3Ftype%3Dm4500_4500_fst_n%26wm%3DY" target="_blank" rel="noopener"><img src="http://dbscthumb.phinf.naver.net/2799_000_1/20131126144005137_M7LXWMRYA.jpg/2_i3.jpg?type=w224_fst_n&amp;wm=Y" alt="햄버거 요리과정"></a></p><p><strong>01.</strong> 햄버거 패티용 양파, 샐러리, 로즈마리는 곱게 다진다. 달군 팬에 양파, 샐러리를 넣어 볶아 수분을 날리고 접시에 펼쳐 식힌다.</p><p><a href="http://terms.naver.com/imageDetail.nhn?docId=1988021&amp;imageUrl=http%3A%2F%2Fdbscthumb.phinf.naver.net%2F2799_000_1%2F20131126144005139_WNK2GBDA7.jpg%2F2_i4.jpg%3Ftype%3Dm4500_4500_fst_n%26wm%3DY" target="_blank" rel="noopener"><img src="http://dbscthumb.phinf.naver.net/2799_000_1/20131126144005139_WNK2GBDA7.jpg/2_i4.jpg?type=w224_fst_n&amp;wm=Y" alt="햄버거 요리과정"></a></p><p><strong>02.</strong> 양송이버섯, 피클, 토마토, 양파는 모양대로 얇게 썬다.</p><p><a href="http://terms.naver.com/imageDetail.nhn?docId=1988021&amp;imageUrl=http%3A%2F%2Fdbscthumb.phinf.naver.net%2F2799_000_1%2F20131126144103273_C7L6PSN50.jpg%2F2_i5.jpg%3Ftype%3Dm4500_4500_fst_n%26wm%3DY" target="_blank" rel="noopener"><img src="http://dbscthumb.phinf.naver.net/2799_000_1/20131126144103273_C7L6PSN50.jpg/2_i5.jpg?type=w224_fst_n&amp;wm=Y" alt="햄버거 요리과정"></a></p><p><strong>03.</strong> 볼에 쇠고기, 돼지고기, 양파, 샐러리, 다진마늘, 로즈마리, 달걀, 빵가루, 굴소스, 소금, 후추를 넣어 섞어 충분히 치댄다. 둥글 납작하게 모양을 만들어 냉장실에서 1시간 동안 숙성한다. (고기를 치댈수록 끈기가 생기나 많이 치대면 으스러지기 때문에 적당히 덩어리질 때까지만 치댄다. 고기는 구우면 줄어들어 빵 크기보다 조금 크게 하는 게 좋다. 중간 부분은 잘 익을 수 있게 약간 눌러준다.)</p><p><a href="http://terms.naver.com/imageDetail.nhn?docId=1988021&amp;imageUrl=http%3A%2F%2Fdbscthumb.phinf.naver.net%2F2799_000_1%2F20131126144105946_PDBZYIEDW.jpg%2F2_i6.jpg%3Ftype%3Dm4500_4500_fst_n%26wm%3DY" target="_blank" rel="noopener"><img src="http://dbscthumb.phinf.naver.net/2799_000_1/20131126144105946_PDBZYIEDW.jpg/2_i6.jpg?type=w224_fst_n&amp;wm=Y" alt="햄버거 요리과정"></a></p><p><strong>04.</strong> 호밀빵은 빵칼로 이등분 한다. 달군 팬에 호밀빵을 넣어 안쪽면을 노릇하게 굽는다.</p><p><a href="http://terms.naver.com/imageDetail.nhn?docId=1988021&amp;imageUrl=http%3A%2F%2Fdbscthumb.phinf.naver.net%2F2799_000_1%2F20131126144107517_DKU2RUTX7.jpg%2F2_i7.jpg%3Ftype%3Dm4500_4500_fst_n%26wm%3DY" target="_blank" rel="noopener"><img src="http://dbscthumb.phinf.naver.net/2799_000_1/20131126144107517_DKU2RUTX7.jpg/2_i7.jpg?type=w224_fst_n&amp;wm=Y" alt="햄버거 요리과정"></a></p><p><strong>05.</strong> 달군 팬에 식용유를 두르고 03의 햄버거 패티를 넣어 노릇하게 굽는다.</p><p><a href="http://terms.naver.com/imageDetail.nhn?docId=1988021&amp;imageUrl=http%3A%2F%2Fdbscthumb.phinf.naver.net%2F2799_000_1%2F20131126144108390_6HWMNVQMV.jpg%2F2_i8.jpg%3Ftype%3Dm4500_4500_fst_n%26wm%3DY" target="_blank" rel="noopener"><img src="http://dbscthumb.phinf.naver.net/2799_000_1/20131126144108390_6HWMNVQMV.jpg/2_i8.jpg?type=w224_fst_n&amp;wm=Y" alt="햄버거 요리과정"></a></p><p><strong>06.</strong> 달군 팬에 식용유 약간을 두르고 양송이버섯을 넣어 소금, 후추로 간하여 볶는다.</p><p><a href="http://terms.naver.com/imageDetail.nhn?docId=1988021&amp;imageUrl=http%3A%2F%2Fdbscthumb.phinf.naver.net%2F2799_000_1%2F20131126144110943_V17ZQL3P8.jpg%2F2_i9.jpg%3Ftype%3Dm4500_4500_fst_n%26wm%3DY" target="_blank" rel="noopener"><img src="http://dbscthumb.phinf.naver.net/2799_000_1/20131126144110943_V17ZQL3P8.jpg/2_i9.jpg?type=w224_fst_n&amp;wm=Y" alt="햄버거 요리과정"></a></p><p><strong>07.</strong> 구운 호밀빵에 안쪽 면에 마요네즈를 펴 바르고 양상추, 토마토, 양파, 햄버거 패티, 치즈, 양송이버섯, 피클을 올리고 토마토케찹을 뿌린다.</p><p><strong>[네이버 지식백과]</strong> <a href="http://terms.naver.com/entry.nhn?docId=1988021" target="_blank" rel="noopener">햄버거 만드는 법</a> (쿡쿡TV)</p><p> 기존의 프로그래밍 방법도 위의 과정을 프로그램적으로 변환해서 만들었을 뿐이다. 이것을 선언적인 관점으로 재해석 하면 아래와 같다. </p><ul><li>햄버거는 제일 아래 빵을 놓고 위에 마요네즈 위에 양상추, 토마토, 양파 위에 햄버거 패티 위에 치즈 위에 볶은 양송이, 피클 위에 토마토 케찹 위에 빵을 얹은 것이다.</li><li>햄버거 패티는 쇠고기, 돼지고기, 양파, 샐러리, 다진마늘, 로즈마리, 달걀, 빵가루, 굴소스, 소금, 후추를 넣어 섞고 치댄 뒤 불에 노릇하게 구은것이다. </li><li>노릇하게 굽는것은 고온의 팬에 재료를 넣고 색이 노릇하게 변할 때 까지 익힌것이다.</li><li>볶는 것은 고온의 팬에 재료를 넣고 자주 섞어 주는 것이다.</li><li>기타 등등.. 다진다. 얇게 썬다등…</li></ul><p> 여기서 주목해야 할 것이 있다.</p><p> 이전의 방식이 어떻게 만드는지(조작적 정의)에 초점이 맞추어져 있다면 이 방식은 음식을 만드는 단계에 각각의 구성요소가 무엇이 있는지(개념적 정의)에 초점이 맞추어져 있다. </p><p>이 방식은 음식을 개념적인 모습으로 표현 했다. 큰 부분으로 부터 각 부분을 설명했기 때문에 이해하기가 쉽고 짧다. 또한 의존관계를 직접 표현했으며 이로인해 순서를 정할 수 있다. 햄버거 패티가 만들어 지는것과 빵을 굽는것과 양송이 볶는 것의 순서를 신경 쓰지 않아도 된다. 어느것을 먼저 만들거나 동시에 만들 수도 있고, 다른사람이 만든 것을 쓸 수도 있다.</p><p> 의존관계를 직접 표현 했기 때문에 의존관계로 부터 시퀀스를 만들 수 있다. 이 시퀀스를 직접 조작하거나 기술하지 않고 외부라이브러리(Rx)를 통해 서술만 한다면 우리는 더 적게 코드를 작성 할 수 있다. 시퀀스로부터 자유로워 지면 어떻게(how)는 적게 사용하면서 어떤것(what)에 대해서 더 많이 생각 할 수 있게 되는것이다. </p><p>[결론은 남들이 Rx쓴다고 막 쓰지 말고 문제를 재정의하고 나서 필요한 부분에 잘 쓰자]</p><p>Example</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> Rxswift</span><br></pre></td></tr></table></figure><p>asdsad</p><p>[주1: 단점은 있다. 라이브러리에 너무 의존적이라서 문제가 발생하면 그 문제를 직접해결 해결해야 한다. 작은 오류도 거대한 라이브러리의 이해 없이는 해결이 어려워 질때도 있다. 이럴때는 라이브러리를 이해하여 해결할 능력을 키우면 해결 된다. 참~ 쉽죠?]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Less-code-Less-bugs&quot;&gt;&lt;a href=&quot;#Less-code-Less-bugs&quot; class=&quot;headerlink&quot; title=&quot;Less code, Less bugs&quot;&gt;&lt;/a&gt;Less code, Less bugs&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="swift, fro, functional, reactive, rxswift" scheme="http://yoursite.com/tags/swift-fro-functional-reactive-rxswift/"/>
    
  </entry>
  
  <entry>
    <title>ArtofSwiftProgramming</title>
    <link href="http://yoursite.com/2017/12/18/ArtofSwiftProgramming/"/>
    <id>http://yoursite.com/2017/12/18/ArtofSwiftProgramming/</id>
    <published>2017-12-17T16:11:11.000Z</published>
    <updated>2017-12-18T07:46:15.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="프로그래머를-위한-간결한-코드-작성-가이드"><a href="#프로그래머를-위한-간결한-코드-작성-가이드" class="headerlink" title="프로그래머를 위한 간결한 코드 작성 가이드"></a>프로그래머를 위한 간결한 코드 작성 가이드</h1><h3 id="Art-of-Swift-Programming"><a href="#Art-of-Swift-Programming" class="headerlink" title="Art of Swift Programming"></a>Art of Swift Programming</h3><h4 id="다시-만난-프로그래밍의-세계에-대한-나의-관점을-예제를-통해-담은-글"><a href="#다시-만난-프로그래밍의-세계에-대한-나의-관점을-예제를-통해-담은-글" class="headerlink" title="다시 만난 프로그래밍의 세계에 대한 나의 관점을 예제를 통해 담은 글"></a>다시 만난 프로그래밍의 세계에 대한 나의 관점을 예제를 통해 담은 글</h4><p>먼저 제목에 대한 오해를 풀어보자면 예술적인 방식으로 작성한 코드나 학술적인 이야기를 감탄사 나오게 작성했다는 의미에서의 Art라는 단어를 쓰지 않았다. </p><p>첫번째로 Art의 다른 의미인 (특수한)기술이나 기예적인 의미를 가진다. 프로그래밍은 기예(craft)아닌가?</p><p>두번째로 Swift는 객체적이며 함수적인 코드를 작성 할 수 있는 다른 언어로 대체 될 수 있다.</p><p>마지막으로 이 글을 쓰면서 <strong>지식 배경이 비슷하다는 조건</strong>하에 쉽게 읽히고 왜 하는지에 대한 이해를 높이며 효율적인 프로그래밍 방법을 설명하려고 노력했다. 이 노력의 과정이 예술과 비슷하다는 느낌을 받아서 Art of..라는 제목으로 글을 쓰게 되었다.</p><p>[모든 글에 달려 있는 링크는 꼭 한번씩 눌러서 살펴보길 바란다. 이해에 도움이 될 것이다.]</p><h2 id="프로그래머에게-좋은-코드란"><a href="#프로그래머에게-좋은-코드란" class="headerlink" title="프로그래머에게 좋은 코드란?"></a>프로그래머에게 좋은 코드란?</h2><p>“내가 생각하는 좋은 코드란 읽는 사람의 정신적 수고를 덜어 줄 수 있는 코드다.”  - 넷상에서 본 글…</p><p> 내가 생각하는 좋은코드는 일정 수준의 비슷한 배경지식을 가진 사람이 읽기 쉬운 코드가 좋은 코드다. 여기에서 중요한것은 배경지식이 비슷하다는 조건인데 많은 사람들이 이부분에서 많은 혼동과 오해 때문에 논쟁거리를 가진다. 지식에 대해 설명을 할 때는 자기가 설명 할 수 있는 가장 쉬운 설명을 통해 해야 하지만 <strong>실제 작업에서는 간단하고 명료하게 작성하는것이 좋다</strong>. 여기에서 <strong>명료하다</strong>라는 말은 그것이 뜻하는 바가 하나(또는 소수)라는 말과 같으며 <strong>간단하게</strong>라는 말은 설명을 많이 하지 않아도 이해 할 수 있다라는 뜻이다. <strong>간단하다</strong>라는 것은 <strong>쉽다</strong>라는 단어와 동의어가 아니다. 설명을 줄여도 이해 할 수 있다는 말은 그 사람의 배경지식이 최소 비슷해야 한다라는 조건이 필요하다. </p><p> 배경지식이라는 말은 이미 알고 있는것들과 그 사람이 경험한 모든 행위중에 기억속에 메모되어 있는 것을 뜻한다. 배경지식이 다를 때 생기는 문제를 예로 들자면 형상관리시스템에 대해 배경 지식이 없고 유용성을 모르는 사람과 형상관리가 필요한 사람이 대화를 나눈다면 서로의 의견차이만 내세울 것이다. 극단 적인 예로 형상 관리의 문제를 경험하지 못했다면 굳이 어려운 시스템을 배워서 해야할 필요성을 못 느낄것이고 형상관리의 필요성을 아는 사람은 그 유용성과 간단함(?)을 증명해야 할 것이다. 다른 예로 언어를 가지고 이야기를 하면 언어는 문화적인 배경을 기반으로 발전하기 때문에 그 언어의 특징이나 문화적인 배경을 이해하지 못하면 뜻을 온전히 받아 들이기 힘들다. 예를 들면 문화적 배경지식이 없다면 대화에 어려움이 있다. 영어와 한글을 잘하는 사람은 생활에 관한 이야기를 쉽게 할수는 있지만 흑인유머나 서부시대에 대한 유머는 배경지식 없이는 이해가 어렵다. 또한 언어적인 차이도 대화를 어렵게 한다. 우리나라 말로 그(녀)들이라는 말은 영어 표현이 힘들다. 보통 They로 번역 되어 앞뒤 맥락으로 이해한다. 나는 쉽고 간결하게 말한다고 생각했지만 상대방에게는 이해할 수 없는 소리가 될 수도 있다는 것이다.</p><p>[주1: 사용하는 언어가 사고방식을 결정한다. “가진 게 망치 뿐이라면….. 모든 게 못으로 보인다”]</p><p>[주2: 사고방식도 그 사람의 배경지식중 하나라고 생각한다]</p><p>[주3: 문화적인 언어 차이도 있지만 언어 자체의 특성으로 인해 이해하기 힘든 경우도 많다. SVO형 언어<strong>(주어-서술어-목적어)</strong>와 SOV형<strong>(주어-목적어-서술어)</strong> 언어의 차이에서도 많은 예가 있다.]</p><p> 다시 본론으로 돌아가서 배경지식이 비슷하면 서로에게 좋은 코드가 되는 기본 조건이 만족 된다. 비슷한 배경지식을 가지기 위한 간단한 방법은 서로간의 지식을 나누고 전파하며 공부하는 것이다. 서로간에 기본적인 지식을 공유하였다면 남은 것은 간결하고 명료한 코드를 작성하기 위한 방법을 아는 것이다. 어떻게 하면 이것이 가능 할까? </p><p>내가 제안하는 방법은 <strong>프로그래밍적 사고방식을 바꾸어 보자는 것</strong>이다. 즉 <strong>패러다임의 전환</strong>이다.</p><p><u><em>문제를 어떻게 해결하는지에 대해 작성하기 보다, 문제가 무엇인지 개념적으로 선언하고 설명하는 방식으로 작성하자.</em></u></p><p>이로 인해 의존관계를 줄일 수 있고 로직을 직접 조작하지 않으면서 문제를 쉽게 설명 할 수 있다면 코드가 간결하며 명료해 지지 않을까?</p><p>나에게 남은 숙제는 <strong>이 방식으로 문제를 해결 하는 방법을 설명하고 이것이 간결하며 명료한 방식이라는 것을 증명</strong>하는 일이다. </p><p>내가 제시 할 방식을 맞고 틀림의 문제가 아닌 가능성에 대한 이야기로 받아들여 주었으면 한다. 세상에 정답은 없다.</p><p>[주4: 프로그램은 입력을 출력으로 변환하는 것이며, 프로그램적 사고는 문제를 정의하고 문제를 해결하는 방식을 말한다.]</p><p>[주5: 프로그래밍적 사고방식에는 Procedural, Object-Oriented, Functional, Reactive, FRP, Imperative, Declarative, operational&amp;conceptual definition 등등.. 수많은 개념들이 있다. ]</p><p>[주6: <strong>패러다임</strong>은 생각하는 방식, 세계관’world view’, 철학적인 체계 또는 기준틀이다. 일반적으로 특정분야의 지식에 적용되며 일련의 가정에 기반을 둔다.]</p><h2 id="모든-사고의-기본-Paradigm"><a href="#모든-사고의-기본-Paradigm" class="headerlink" title="모든 사고의 기본_ Paradigm"></a>모든 사고의 기본_ Paradigm</h2><p> 현실에서의 사고방식은 사람들은 사고를 할 때 ‘사실’이라고 믿는 몇 가지 무의식 적인 가정을 근거로 판단 한다. 이런 가정이 참인지 거짓인지는 중요하지 않다. 자신의 가정을 현실 세계 사람들과 공유하고 이를 통해서 의사소통을 하게되는데 서로 다른 사고방식을 가진 사람을 만나게 되면 다른 가정으로 인해 의사소통은 어려워 진다. 프로그래밍 적인 사고방식도 이와 크게 다르지 않다. 내가 제시하는 방식에 대해 이해하기 전까지 기존 사고방식으로 섣부른 판단을 하지 않았으면 좋겠다. 당신이 편견을 가져 버린다면 앞으로 내가 하는 말의 의미가 퇴색되기 때문이다. 자 이제 편견을 버리고 새로운 패러다임을 받아 들여보자. </p><p> 내가 제안하는 프로그래밍 방식은 <strong>DCTP( Denotative, Continuous-Time Programming</strong>) 다. </p><p>이것을 한마디로 정의해 보면, <strong>각각의 구성요소가 무엇을 뜻하는지 개념적인 모습으로 선언하고 서로간에 합성을 통해 문제를 해결하며, 서로의 의존관계는 이벤트 기반이며 입력에 반응하여 동작하는 데이터의 흐름으로 동시 또는 다른곳에서 처리하게 하는 방식이다.</strong></p><p> [DCTP는 실제로는 간단한 아이디어라고 말할 수 있고 실제로도 간단하다. <del>다시 말하지만 간단한 것과 이해하기 쉬운것은 다르다. 함정카드 발동!</del> ]</p><p>[이름에 대한 이야기가 궁금하다면 제일 하단의 [번외편 - DCTP 이름의 의미] 부터 보고 오면 된다.]</p><p>[만약 모르는 단어가 있다면 인터넷이나 사전을 통해 검색해보고 와라. 제발 그냥 넘어가지 말아줬으면 한다. 그래도 이해가 안된다면 코멘트를 남겨라. 내가 틀렸다면 수정을, 아니라면 더 자세한 설명을 드리겠다.]</p><p>연관 된 개념 - declarative, operational&amp;conceptual definition, functional, reactive</p><h2 id="왜-Denotative-Continuous-Time-Programming-인가"><a href="#왜-Denotative-Continuous-Time-Programming-인가" class="headerlink" title="왜 Denotative, Continuous-Time Programming 인가?"></a>왜 Denotative, Continuous-Time Programming 인가?</h2><p> “내가 단어를 사용할 때는 말이야” 험프티 덤프티가 상당히 경멸하는 듯한 어조로 말했다. “그 단어는 정확히 내가 쓰기로 선택한 뜻을 나타내지. 더도 덜도 아냐” - Lewis Carroll, 거울 나라의 앨리스 중</p><p> 우선 DCTP의 정의를 하나씩 펼쳐서 알아보자.</p><p> <strong>각각의 구성요소가 무엇을 뜻하는지 개념적인 모습으로 선언하고 서로간에 합성을 통해 문제를 해결하며, 서로의 의존관계는 이벤트 기반이며 입력에 반응하여 동작하는 데이터의 흐름으로 동시 또는 다른곳에서 처리하게 하는 방식이다.</strong></p><p>첫번째로, 각각의 구성요소가 무엇을 뜻하는지 개념적인 모습으로 선언한다고 말하고 있다. 이는 선언적(declarative) 프로그래밍에 대한 이야기 이다. </p><p>두번째로, 서로간에 합성을 통해 문제를 해결을 말하고 있다. 이 부분은 함수의 합성성(Compositionality)에 대한 이야기 이다.</p><p>세번째로, 서로의 의존관계는 이벤트 기반이며 입력에 반응하여 동작하는 데이터의 흐름이라고 말하고 있다. 이는 반응형에 대한 이야기다. (이 글에서는 Reactive Extension ‘이하 Rx’ 라이브러리를 사용하여 설명한다.)</p><p>마지막으로, 동시 또는 다른곳에서 처리하는 방식이라고 했다. 이는 스레드에 대한 이야기 이다.</p><p> 이 네가지 방식을 통해 문제를 간단하게 할 수 있을까? 예제를 만들고 그것을 풀어가면서 설명해 보자. 필자는 백수라서 조카들과 함께 생활 하고 있다. 집안일을 하다보니 참 어려운 점이 많았는데 그중에 빨래와 요리가 귀찮았다(…..) 그래서 귀찮은 빨래와 요리를 하는방법에 대한 프로그래밍 예제를 만들어 보기로 했다.</p><p> 당신은 세탁 하는 방법을 프로그램으로 표현 한다면 어떻게 하겠는가? 한번 생각해 보자.</p><p>.</p><p>.</p><p>.</p><p>귀찮은가…? 실제 코드가 아니여도 괜찮다. 의사코드로만 해봐도 괜찮다.</p><p>.</p><p>.</p><p>.</p><p>그래도 싫은가? 그렇다면 어떤 구성요소로 어떤일을 할지만이라도 정리해 보자.</p><h3 id="의존성-관점에서-생각해-보기"><a href="#의존성-관점에서-생각해-보기" class="headerlink" title="의존성 관점에서 생각해 보기"></a>의존성 관점에서 생각해 보기</h3><p> 우선 아래와 같은 단계로 정리를 시도했다.</p><h6 id="세탁에-대한-개발-프로세스"><a href="#세탁에-대한-개발-프로세스" class="headerlink" title="세탁에 대한 개발 프로세스"></a>세탁에 대한 개발 프로세스</h6><ul><li>의류나 이불을 사용한다.</li><li>오염 된 세탁물을 모아둔다</li><li>세탁물이 일정수준 모이면 세탁기에 넣는다</li><li>세탁기에 세제와 섬유 유연제를 넣는다</li><li>세탁기에 가동한다</li><li>탈수기로 옴긴다</li><li>탈수기로 탈수를 한다</li><li>탈수가 끝나면 건조기로 옴긴다</li><li>건조기를 가동하여 세탁물을 말린다</li><li>마른 세탁물를 꺼낸다.</li></ul><p> 위의 대부분의 과정이 시퀀스로 연결 되어 있다. 건조기는 탈수기 단계 이후에 실행 하며 탈수기는 세탁기 이후에 실행된다. 세탁기는 물과 세제와 섬유유연제가 준비 된 다음에 동작이 된다.(예외 케이스는 많지만 여기서 다루지는 않는다) 의존관계가 없는 단계도 있다. 위 예시에는 의류나 이불을 사용하는 단계이다. 몇명이서 사용하든 얼마나 많은양을 사용하든 문제 되지 않는다. 심지어 어떤 자원(인간)은 의류를 사용만 해도 세탁 프로세스가 끝나는 진풍경을 볼 수가 있다. (현실도 그렇지 않은가?)</p><p>소프트웨어는 프로그래머가 작성하고 기계가 실행하는 여러 단계의 시퀀스로 표현해왔다. 각 단계는 이전 단계와 관련 된다. 일부는 직전단계에 의존하며, 일부는 휠씬 더 앞의 단계에 의존한다. 이를 의존성이라고 한다.</p><p>[주1: 여기에서의 시퀀스는 연속적인 순서를 가진 요소들이라는 추상적인 뜻이다.]</p><p> 위 단계를 기존방식으로 코드를 만들어서 <a href="https://gist.github.com/AidenJLee/35368354390957bb8d0fa3ddb12724da" target="_blank" rel="noopener">Gist</a>에 올렸다. 코드에 대한 자세한 설명은 생략한다. (미완성-의미적인 코드)</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">var</span> 세탁된의류: [<span class="type">String</span>] = []</span><br><span class="line"><span class="keyword">let</span> 에르쥐세탁기 = 세탁기(세탁물들: [<span class="string">"하루입은 티"</span>, <span class="string">"굴러다니는 운동복"</span>, <span class="string">"곰팡이 핀 양말"</span>])</span><br><span class="line">  |     <span class="keyword">self</span>.세탁준비(세탁기: 에르쥐세탁기)</span><br><span class="line">  |     <span class="keyword">if</span> 에르쥐세탁기.세탁가능한상태체크() &#123; </span><br><span class="line">  |         세탁된의류 = 에르쥐세탁기.세탁을한다()</span><br><span class="line">  |     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  |         <span class="built_in">print</span>(<span class="string">"세탁 준비를 체크해 주세요"</span>)</span><br><span class="line">  |     &#125;</span><br><span class="line">  |     <span class="keyword">let</span> 사무성건조기 = 건조기()</span><br><span class="line">        <span class="comment">// ...세탁된의류[] 값을 가지고 이하 건조 로직</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드 내용중 앞에 “|”가 있는 부분은 순서가 중요하다. 이 순서가 지켜지지 않으면 세탁프로세스는 제대로 동작 하지 않을것이다. 다시 말하자면 작성한 프로그램이 시퀀스에 의해서 동작하도록 만들어 졌기 때문이다. 세탁물을 받거나 세탁기에서 건조기로 이어지는 이벤트와 리스너는 구현은 하지 않았다. 말로 풀어보자면 버튼을 통해 세탁물을 생성하는 이벤트나(IBAction을 이용가능) 세탁물이 충분히 모였다는 이벤트가 발생하면 이를 받는 리스너를 통해 이벤트 처리를 할 수 있다.(객체에서 메세지를 던지거나 기타 이벤트와 리스너로 처리가능) </p><p> 처리순서는 코드가 이벤트를 언제 전파하느냐와 어떤 리스너가 등록되어 있는지에 따라 달라지는데 여기에서 순서가 예측불가능한 상황이 발생할 수 있다는 일차적인 문제가 발생한다. 이런 단순한 형태가 아니라 큰 프로젝트의 소스이며 어느 한 부분의 기능을 변경해야 한다고 생각해 보자. 우리는 자연스럽게 의존관계의 측면에서 생각한 뒤 작업을 할 것이다. 지금 추가하려는 기능이 이전에 영양을 미치는 부분과 이후에 영향을 미치는 범위를 계산하여 작업 할 것이다. 이런 작업의 대부분은 관계를 시퀀스로 바꾸는 일이며, 당신이 이런일을 잘할것이라는 것은 믿어 의심치 않는다. 하지만 더 일찍 일어 발생하거나 늦게 벌어지게 만들려면 기존 시퀀스가 가지고 있는 모든 의존성을 완전히 이해해야 한다. 이해해야 하는 문제가 너무 커지는 이차적인 문제가 생겨났다. 이를 해결하는 방법은 선언적으로 생각하기와 반응형이다. </p><p>[주2: 의존관계를 시퀀스로 표현하는 것은 구현에 문제가 되기 보다 코드를 바꾸려고 할 때 발생한다. 어떤 일을 더 일찍하거나 늦게 하려면 기존 시퀀스가 암시하는 모든 의존성을 이해해야 변경 할 수 있기 때문이다. (이 문제를 해결하기 위해서 Optional개념을 사용하기도 한다. 시퀀스상에 예측불가능한 순서에 의해 값이 있는지 없는지 알 수 없기 때 Optional로 처리한다. 값이 없을 때는 원하는 결과가 안나온다는 단점이 있다.)</p><p>[주3: DCTP는 이런 시퀀스를 자동으로 처리해 주기 때문에 의존관계에만 관심을 가질 수 있게 해준다. 그렇기 때문에 DCTP는 문제를 설명(problem description)라는 방식으로 프로그램을 할 수 있다. 여기서 자동이라는 말은 의존관계만 만들면 시퀀스는 라이브러리(RxSwift)를 통해 대부분 처리 가능하다는 뜻이다.]</p><h3 id="선언적-Declarative-관점에서-생각해-보기"><a href="#선언적-Declarative-관점에서-생각해-보기" class="headerlink" title="선언적(Declarative) 관점에서 생각해 보기"></a>선언적(Declarative) 관점에서 생각해 보기</h3><p> 시퀀스는 의존관계로 부터 만들 수 있기 때문에 시퀀스를 전혀 기술하지 않으면 코드를 더 적게 작성 할 수 있다. 시퀀스에서 자유로워 지면 어떻게(how)는 적게 사용하면서 어떤것(what)에 대해서 더 많이 생각 할 수 있게 된다. 위에 만들었던 코드는 원하는 결과를 얻기 위해 여러 단계를 설명하는 시퀀스롤 사용하여 표현했다. 이것은 흐름제어: 어떻게(how)와 구문(statement)을 사용한 방식이다. 새롭게 작성 할 <strong>선언적인</strong> 방식은 <strong>각각의 타입과 구성요소의 의미를 정확히 지정해주도록 작성</strong>한다. 이것은 <strong>데이터 흐름: 무엇을(what)</strong>과 <strong>표현식(expression)</strong>을 사용한 방식이다. </p><p>[주1: 문과 식의 차이를 모른다면…. 검색하거나 또는 <a href="http://www.bsidesoft.com/?p=760" target="_blank" rel="noopener">자바스크립트의 식과 문</a>이라는 글을 읽어보아라. 의미는 알 수 있다.]</p><p><strong><em>세탁에 대한 개발 프로세스</em></strong> 를 선언적 형태로 다시 정리해 보자</p><ul><li>세탁 바구니는 오염 된 세탁물을 모아 두는 곳이다</li><li>세탁기는 물과 세제와 섬유유연제로 세탁물의 오염을 씻어낸다</li><li>탈수기는 세탁물과 물을 분리 시켜 낸다</li><li>건조기는 세탁물에 남아 있는 물기를 제거한다</li></ul><p>이것은 세탁의 개념적인 모습에 가깝다. 의존관계가 직접 표현했으며 각 부분은 동시에 처리 되거나 다른곳에서 처리 할 수도 있다. 이전에 정의한 내용은 세탁을 어떻게 조작하여 할 것인지(<strong>조작적 정의</strong>)에 초점이 맞추어져 있다면 이 방식은 세탁을 하기 위해 필요한 단계에 무엇이 있는지를 정의해서(<strong>개념적 정의</strong>) 세탁을 정의 했다. 여기서 의문을 가지는 독자가 있을것이다. 이전에는 조작에 대한 정의와 무엇인지에 대한 정의가 같이 있었다면 지금은 조작에 대한 이야기가 없어졌다. 이부분을 어떻게 할 것인가? 여기에 대한 답은 <strong>반응형(Reactive Programming)</strong>과 <strong>조작적인 정의(Operational definition)</strong>다. </p><p> 아래는 각각의 개념에 대해서 간략히 설명 후 RxSwift로 넘어 가겠다. 분량이 너무 길어진….다.</p><h3 id="조작적인-정의-Operational-definition-VS-개념적인-정의-Conceptual-definition"><a href="#조작적인-정의-Operational-definition-VS-개념적인-정의-Conceptual-definition" class="headerlink" title="조작적인 정의(Operational definition) VS 개념적인 정의(Conceptual definition)"></a>조작적인 정의(Operational definition) VS 개념적인 정의(Conceptual definition)</h3><p> DCTP의 작동을 이해 하는 방법은 두가지다. 조작적인 이해와 개념적인 이해다.</p><p> 앞으로의 프로그래밍에서 로직은 데이터의 흐름이다. 당신은 데이터의 흐름에 집중해야한다. 데이터는 당신의 로직 안으로 들어와 변화를 겪은 뒤 출력 부분을 통해 외부로 나간다. 데이터는 입력에서 출력으로 흐르며 DCTP의 근본은 입력적인 측면에서 출력을 선언하는 기술이다. 개별의 이벤트 값이 아니라 데이터 흐름이라는 수준에서 개념적인 작업을 해야 한다. DCTP에서 함수형 프로그래밍은 로직을 직접 조작하는게 아니라 로직을 기술하는 언어의 문장을 변경한다. </p><p>대부분의 프로그래머는 조작적인 사고에 익숙하지만 이제는 개념적인 사고에 익숙해 지기를 바란다. DCTP에서 조작적 사고는 더 복잡한 접근 방식이자 불필요한 세부 사항으로 프로그램에 거품을 만들뿐이다.</p><p> 문장이 너무 어려운가? 사용적인 측면에서 예를 들면 세탁프로세스에서 세탁의 본질에 대한 것을 위주로 구현하고 세탁물 이동이나 세탁, 탈수, 건조 같은 이벤트는 Rx 라이브러리를 통해 조작 하는 것이다. </p><p><img src="/images/oac.jpeg" alt="Image"></p><h3 id="이벤트가-뭐야"><a href="#이벤트가-뭐야" class="headerlink" title="이벤트가 뭐야?"></a>이벤트가 뭐야?</h3><p> 대부분의 애플리케이션은 스레드나 이벤트의 모델을 중심으로 구조를 잡고 있다. 이들은 모두 입력에 대한 반응으로 상태를 변화 시키는 것을 관리 한다. 하지만 두가지는 그 목표를 달성하는 방법이 다르다. 이벤트는 프로그램에서 이곳저곳으로 전달되는 개별적으로 분리된(discrete) 비동기적인 메세지다. 이벤트는 그 순서가 명확하지 않거나 구성요소 간의 상호작용이 복잡할 때 사용하는것이 적합하다. 전형적으로 그래픽 사용자 인터페이스에서 주로 사용된다. </p><p>[주: 스레드는 상태 변화를 제어 흐름으로 모델링 한다. 스레드는 상태 변화 순서가 명확히 정의 될 때나 I/O에 잘 어울린다. 액터나 제너레이터도 이 범위에 들어간다.]</p><h3 id="Reactive-Programming"><a href="#Reactive-Programming" class="headerlink" title="Reactive Programming"></a>Reactive Programming</h3><p> Reactive Programming: 프로그램을 전통적인 제어의 흐름이 아니라 1.이벤트 기반이며 2.입력에 반응하여 동작하고 3.데이터의 흐름으로 보는 것을 뜻하는 광범위한 용어이다. 이 용어는 이러한 목적을 어떻게 달성해야 하는지를 기술하고 있지는 않다. 반응형 프로그래밍은 프로그램 구성요소 간의 더 느슨한 결합을 허용하며 그에 따라 코드가 더 모듈화 되는 특징이 있을 뿐이다. </p><ul><li>이벤트 기반</li><li>입력에 반응하여 동작</li><li>데이터의 흐름을 보는것</li></ul><p>을 프로그램 적인 용어로 풀자면 입력에 반응해야 하기 때문에 비동기로 동작하며 데이터의 흐름을 보기 위해서 관찰 가능한 스트림을 사용해야 한다. </p><p>종합해서 한마디로 하자면</p><ul><li>RP는 비동기와 이벤트 기반의 데이터 스트리밍(Asynchronous and Event-based Data Streaming)을 관찰 가능한 시퀀스(Observable Sequences)로 변환해 개발하는 방식이다.</li></ul><p>용어들의 연관관계가 눈에 보이는가? 그렇다면 다행이고 아니라면 어느 부분이 이해 안가는지 알려주길 바란다. </p><h3 id="Functional-Programming"><a href="#Functional-Programming" class="headerlink" title="Functional Programming"></a>Functional Programming</h3><p>설명에 전반적으로 깔려 있는 함성성이니 불변이니와 같은 특성은 함수형 프로그래밍에서 왔다. 함수형 프로그래밍을 정의해 보면 수학적 의미의 함수에 기반한 프로그래밍 방식 또는 패러다임이다. 함수형 프로그래밍은 공유되는 변경가능한 상태 Mutable state를 의도적으로 회피한다. 그에 따라 immutable 데이터 구조를 사용한다. 함수형 프로그래밍은 합성성을 강조한다. 합성성은 수학적으로 함수의 결합 가능한것을 뜻한다. 그 외에 다양한 정의가 있지만 여기에서 필요한 함수형 프로그래밍의 특징은 합성성이다. </p><p>FP 합성성: 새로움 함수를 만들거나 계산하기 위해 둘 이상의 함수를 조합하는 과정에서 합성 <code>f . g</code>(점은 “합성됨”을 의미)은 <code>f(g(x))</code>와 동일한것을 뜻함</p><p><a href="http://sungjk.github.io/2017/07/17/fp.html" target="_blank" rel="noopener">링크: 함수형 프로그래밍에 관한 설명 글</a></p><h3 id="Reactive-Extension-Rx"><a href="#Reactive-Extension-Rx" class="headerlink" title="Reactive Extension(Rx)"></a>Reactive Extension(Rx)</h3><p> 선언적인 방식을 통해 구현할 때 조작적 정의에 대해 설명하려고 <strong>조작적인 이해와 개념적인 이해, 이벤트, 반응형을 설명</strong>하는 기나긴 길을 돌아 왔다. 위 설명을 잘 이해하면 좋겠지만 내가 봐도 설명이 부실하다. 허나 걱정하지 말자. 다 Rx를 설명 하려고 풀어서 작성했을 뿐이다. 이해가 안된다면 우선 RxSwift를 사용하는 법부터 배워도 된다. 차를 운전 할 때 차의 구동원리를 몰라도 운전만 잘하면 베스트 드라이버가 될 수 있다. </p><p> 나의 관점에서 Rx는 크게 네가지 부분으로 나누어져 있다.</p><ol><li>Signal(Observable)을 만드는 부분</li><li>신호 받고 신호를 보낼수 있는 Observer(Subject)부분</li><li>신호 사이에 변환(조작)하는 Operator부분</li><li>어디서 동작해야하는지 지정하는 Schedule(Thread)부분</li></ol><p>각각 부분에 대해서는 설명하는 좋은 글들이 많기 때문에 아주 입문적인 내용만 다루겠다. 자세한 내용은 <a href="https://pilgwon.github.io/blog/2017/09/26/RxSwift-By-Examples-1-The-Basics.html" target="_blank" rel="noopener">다음 링크</a>를 읽거나 검색하기를 바란다.</p><h4 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h4><p>Observable<t>는 객체를 이벤트와 함께 랩핑하여 비동기적으로 데이터<t>를 전달 할 수 있는 기능을 가진다. 관찰 할 수 있게 만든다는 이야기는 신호를 발생한다는 이야기며 다른 관잘자(<strong>Observer</strong>)가 이 값을 구독(subscribe) 할 수 있다. 이때 발생하는 신호는 onNext/onError/onComplete이다. 그외에도 불변적, SnapshotData등의 많은 특징들이 있지만 패스.</t></t></p><h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><p>신호(Observable)를 방출할 수 있고 신호를 구독(subscribe)할 수 있는 객체다. Rx에서는 보통 AnyObserver나 Subject라는 형태로 만들고 있으다. </p><h4 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h4><p>다시 말하지만 프로그램은 입력(<strong>Observable</strong>)을 출력(<strong>Observer</strong>)으로 변환(<strong>Operator</strong>)하는 것이다.  Rx에서 모든것은 시퀀스다. Ovservable class에는 비동기 작업을 할 수 있도록 수많은 추상화 메소드들로 구성되어 있다. 이 메소드들은 작게 분리되어 있으며 서로 합성이 가능 하기 때문에(함수의 합성성, 표현식) 퍼즐 조각처럼 서로 구성할 수가 있다. 이러한 연산기능을 Operator라고 한다. </p><p>[주1: 보통 모든것이 스트림이다라고 한다. 이는 조금 다른데… 이에 대해서 논쟁해봐야 손가락만 아프고 개발에 별 도움이 안되니 그냥 필자는 필자스타일대로 시퀀스라고 하겠다. 스트림이라고 이해하는게 쉽다.]</p><h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>스케줄러는 Rx를 dispatch queues와 동일하게 사용한다. </p><p>[주1: Dispatch Queue는 Task를 적재하는 데이터 구조다. 데이터 구조의 Queue이므로 작동 방식이 Serial(순차적)이든 Concurrent(동시)이든, 언제나 FIFO(First In First Out)방식으로 동작한다.]</p><p>이렇게만 설명하고 넘어가고 싶다… 사실 이게 전부인데…ㅠㅠ(글쓰기에 너무 지친 상태라서 서두르며 마무리 짓는 경향이 있다)</p><p>욕먹을거 같아서 추가 설명을 한다. 아래는 스레드와 프로세스에 대한 설명글을 긁어 왔다.</p><p><strong>프로세스</strong>란 하나의 작업을 처리 하기 위해서 운영체제로 부터 시스템 자원(주소공간, 메모리 영역, 레지스터, 클럭, 파일, 입출력장치 등)을 할당받아 실핼 중인 프로그램을 뜻한다. </p><p><strong>스레드</strong>란 한 프로레스가 동작되는 흐름의 단위를 말한다. 일반적으로 프로세스는 하나의 스레드를 가지고 있지만 프로그램 환경이나 중요도에 따라서 스레드를 이동하면서 실행되거나 동시에 실행 될 수 있다.</p><p>프로세스는 자신만의 고유 공간과 자원을 할당받아 사용하며 스레드는 다른 스레드와 일부 자원과 공간을 공유하며 사용한다</p><p>이해 안가도 상관 없다. 쉽게 설명하자면 스레드란 일(task)을 처리하는데 있어서 중요도가 높은 작업과 낮은 작업을 분리하여 그 실행 순서를 정해서 처리하는 것을 뜻한다. 현실 적인 예를 들어주면 일상 생활에서도 개발 하다가 문서작업 하다가 사장님이 부르면 작업 잠시 멈추고 달려가지 않는가? 우리의 뇌가 우선순위를 정해서 일의 처리 순서에 맞게 작업하는 것이다. </p><p> Rx에서 Scheduler는 내부적으로 스레드를 이용하여 작업의 우선순위를 관리하는 역활을 한다. 예를 들면 네트워크를 타고 들어온 데이터를 맵핑하는 작업이 시간이 오래걸리는 작업인데 메인스레드에서 실행되고 있다면 UI가 제대로 처리되지 못하여 얼어붙는 현상이 나타날 것이고 이것은 최악의 유저경험을 주게 될 것이다. 우리는 Scheduler만 처리하면 자동적으로 Thread를 처리하게 되는것이다.</p><h3 id="DCTP-정리"><a href="#DCTP-정리" class="headerlink" title="DCTP 정리"></a>DCTP 정리</h3><p> 지금까지 너무 다양하고 많은 개념들을 설명해 왔다. 많은 설명은 이해를 어렵게 한다. 하지만 각각의 개념을 알아야 어떤 부분에 어떤 기능을 사용하고 왜 사용하는지 알 수 있다고 생각에 과도한 설명을 했다.</p><p> 이쯤에서 다시 한번 정의를 보자.</p><p> <strong>각각의 구성요소가 무엇을 뜻하는지 개념적인 모습으로 선언하고 서로간에 합성을 통해 문제를 해결하며, 서로의 의존관계는 이벤트 기반이며 입력에 반응하여 동작하는 데이터의 흐름으로 동시 또는 다른곳에서 처리하게 하는 방식이다.</strong></p><p>심플한 정의다. </p><p>심플한 정의는 심플한 구현을 할 수 있게 해준다. </p><p>정의 만으로는 구현이 도움이 안된다. 특징을 살펴보고 이를 기반으로 실제 프로젝트를 구현하는 단계로 넘어가자.</p><ul><li>DCTP는 리스터나 콜백 또는 관찰자 패턴과 대치 한다</li><li>DCTP는 이벤트 위주의 로직을 조합 가능한 모듈로 코딩하는 방법이다</li><li>DCTP는 프로그램의 입력에 대한 반응 또는 데이터 흐름으로 표현한다.</li><li>DCTP는 프로그램 상태를 관리하는데 룰을 부여한다</li><li>DCTP에서는 의존관계를 자동으로 결정하기 때문에 올바른 시퀀스를 보장 할 수 있다</li><li>DCTP는 기계의 영역보다는 문제의 영역에서 일에 대해 이야기 한다. 시퀀스는 의존관계로 부터 만들 수 있기 때문에 시퀀스를 전혀 기술하지 않으면 코드를 더 적게 작성할 수 있다. 그 결과 ‘어떻게-how’는 적게 사용하면서 ‘어떤 것-what’을 더 많이 사용하게 되었다.</li></ul><p>위와 같은 특징을 구현하기 위해서 Functional, RxSwift를 사용해 실제 프로젝트를 만들어 보자. 샘플은 두가지를 제작해 보겠다. 첫번째는 위에 예시를 든 세탁 프로세스를 구현한 것이며 두번째는 필자는 요즘 여행 관련 된 앱을 제작중이이기 때문에 앱 기능중 하나인 여행 출발일과 도착일 기반으로 다양한 상황에 대응하는 방법을 제작해 보겠다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">enum ShirtSize: Int &#123;</span><br><span class="line">    case ls = 0, s, m, x, lx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Cloth &#123;</span><br><span class="line">    let price: Int</span><br><span class="line">    let size: ShirtSize</span><br><span class="line">    var name: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    let bag = DisposeBag()</span><br><span class="line">    </span><br><span class="line">    @IBOutlet weak var shirtButton: UIButton!</span><br><span class="line">    @IBOutlet weak var socksButton: UIButton!</span><br><span class="line">    @IBOutlet weak var blanketButton: UIButton!</span><br><span class="line">    </span><br><span class="line">    @IBOutlet weak var laundryBoxTF: UITextView!</span><br><span class="line">    var laundryBasket: Variable&lt;[Cloth]&gt; = Variable([])</span><br><span class="line">    var cleanCloths: Variable&lt;[Cloth]&gt; = Variable([])</span><br><span class="line">    </span><br><span class="line">    @IBOutlet weak var lbWashedCloth: UILabel!</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        configureRx()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func washing(cloths: [Cloth]) &#123;</span><br><span class="line">        print(&quot;세탁중입니다!&quot;)</span><br><span class="line">        for cloth in cloths &#123;</span><br><span class="line">            let name = &quot;세탁완료 된 \(cloth.name)&quot;</span><br><span class="line">            cleanCloths.value.append(Cloth(price: cloth.price, size: cloth.size, name: name))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func configureRx() &#123;</span><br><span class="line">        let addShirt = shirtButton.rx.tap</span><br><span class="line">            .throttle(0.5, scheduler: MainScheduler.instance)</span><br><span class="line">            .map(&#123; _ in</span><br><span class="line">            return Cloth(price: Int(arc4random_uniform(100000) + 10000), size: ShirtSize(rawValue: Int(arc4random_uniform(4)))!, name: &quot;잘 때 입는 셔츠&quot;)</span><br><span class="line">        &#125;).asObservable()</span><br><span class="line">        </span><br><span class="line">        let addSocks = socksButton.rx.tap</span><br><span class="line">            .throttle(0.5, scheduler: MainScheduler.instance)</span><br><span class="line">            .map(&#123; _ in</span><br><span class="line">            return Cloth(price: Int(arc4random_uniform(100000) + 10000), size: ShirtSize(rawValue: Int(arc4random_uniform(4)))!, name: &quot;구수한 향기의 양말&quot;)</span><br><span class="line">        &#125;).asObservable()</span><br><span class="line">        </span><br><span class="line">        let addBlanket = blanketButton.rx.tap</span><br><span class="line">            .throttle(0.5, scheduler: MainScheduler.instance)</span><br><span class="line">            .map(&#123; _ in</span><br><span class="line">            return Cloth(price: Int(arc4random_uniform(100000) + 10000), size: ShirtSize(rawValue: Int(arc4random_uniform(4)))!, name: &quot;지도 그린 이불&quot;)</span><br><span class="line">        &#125;).asObservable()</span><br><span class="line">        </span><br><span class="line">        // 세탁물 바구니에 담기</span><br><span class="line">        _ = Observable.of(addShirt, addSocks, addBlanket)</span><br><span class="line">            .merge()</span><br><span class="line">            .subscribe(&#123; (laundry) in</span><br><span class="line">            if let cloth = laundry.element &#123;</span><br><span class="line">                self.laundryBasket.value.append(cloth)</span><br><span class="line">                self.laundryBoxTF.insertText(&quot;\(cloth.name)&quot; + &quot;,&quot; + &quot; &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).disposed(by: bag)</span><br><span class="line">        </span><br><span class="line">        // 5개 이상이면 세에~타~악~</span><br><span class="line">        laundryBasket.asObservable().filter &#123; (data) -&gt; Bool in</span><br><span class="line">            return data.count &gt;= 4</span><br><span class="line">            &#125;.subscribe(&#123; (data) in</span><br><span class="line">                if let cloths = data.element &#123;</span><br><span class="line">                    self.washing(cloths: cloths)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .disposed(by: bag)</span><br><span class="line">        </span><br><span class="line">        cleanCloths.asObservable().bind &#123; (cloths) in</span><br><span class="line">            var resultText = &quot;&quot;</span><br><span class="line">            for cloth in cloths &#123;</span><br><span class="line">                resultText = self.lbWashedCloth.text! + cloth.name + &quot;,&quot; + &quot; &quot;</span><br><span class="line">            &#125;</span><br><span class="line">            self.lbWashedCloth.text = resultText</span><br><span class="line">        &#125;.disposed(by: bag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>샘플 작성중</p><hr><p>글 작성중….</p><p>와 내용 너무 많다…. ㅏㅇ리;ㅁㅇㄹㅁㄴㅇ룸;하ㅣ룸;ㄴㅇ리ㅏㅜ </p><h3 id="장단점"><a href="#장단점" class="headerlink" title="장단점"></a>장단점</h3><p> 스레드에서는 시퀀스를 표현할 수 있다. 이벤트로는 의존관계를 표현할 수 있다. 상황에 따라 둘다 필요하다. 하지만 의존관계를 스레드로 표현하거나 이벤트를 시퀀스로 표현하는데는 많은 문제가 생긴다</p><p>또한 의존관계를 기존의 방식으로 프로그래밍하게 되면 프로그램이 복잡해 질 수록 문제가 발생한다. 어떠한 기능이 더 일찍 또는 늦게 발생하게 만들려면 기존 시퀀스와 연관이 있는 모든 의존성을 이해해야 한다. (일반적인 리스너나 콜백을 통한 처리의 문제는 실행 순서가 예측 불가능 하다는데 있다.) DCTP에서는 의존관계를 직접 표현하므로 필요한 의존 관계를 직접 더하거나 뺄 수 있고 자동으로 시퀀스가 갱신되기 때문에 문제가 없는편이다. 시퀀스에서 실수하기란.. 의도적이지 않다면 힘든일이다. 그럼 DCTP에서는 문제가 없을까? 아니다 반대로 기존 프로그래밍에서는 데이터나 개념에 대한 정의를 새로하거나 추가하는데 문제점이 적다. 하지만 DCTP에서는 데이터나 개념에 대한 정의가 바뀌게 되는 경우 변경되는 부분이 광범위해 지는 케이스가 있어서 곤란함을 겪게 된다. 서로간의 장단점이 있기 때문에 어느곳에 적용할 지는 독자의 판단에 맡긴다. </p><p>[주1: 단점이라고 적은 부분은 Clean Architecture를 통해 어느정도 보환이 가능하다]</p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p> 먼길을 돌아서 오느라 수고가 많았다. 이 기나긴글을 쓴 이유는 하나다. <u>우리는 문제를 해결 하기 위해서 프로그래밍을 한다</u>. 문제를 어떻게 처리해야 할지에 대해서 프로그래밍하는것보다 문제가 어떤것인지 개념적인 사고로 바라보면서 의존관계를 줄이고, 로직을 직접 조작하지 말고 로직을 표현하고 조합하여 데이터흐르게 하여 문제를 설명하는 방식으로 해결하는 시점을 가지면, 문제를 해결하는 고난의 길을 조금이나마 쉽게 갈수 있지 않을까 하는 바램에서 작성하였다.</p><p>이 글이 도움이 되는 사람이 한명이라도 있다면 주말을 투자해 글을 작성한 보람이 있을 것 같다. </p><p>궁금증이나 하고 싶은말이 있다면 entist@me.com 으로 연락하면 된다.</p><p>당신이 하는 일에 도움이 되길! Good luck!</p><p>[사담: 쓰다가 지쳐서 중반부터 급하게 마무리 하려고 하다보니 용두사미가 된것 같아서 아쉽다……조금씩 업데이트를 해보겠다.]</p><h2 id="번외편-DCTP-이름의-의미"><a href="#번외편-DCTP-이름의-의미" class="headerlink" title="[번외편 - DCTP 이름의 의미]"></a>[번외편 - DCTP 이름의 의미]</h2><p> 비밀을 고백하자면 이것은 새로운 용어를 사용했을뿐 그다지 새로운 것은 아니다. 또한 이미 많은 사람들이 알고있다. DCTP의 다른 이름은 <strong>Functional Reactive Prograaming</strong> 이다. 그럼 여기서 왜 새로운 단어를 사용했을까? 라는 의문점이 생긴다. 이유는 간단하다. Functional하고 Reactive한 개념을 사용하지만 순수한 FRP가 아니고 OOP적인 프로그래밍에 문제되는 부분을 Functional과 Reactive로 바꾸기 때문이다. 용어에서 오는 거부감과 이해의 불일치를 줄이기 위해 새로운 단어를 사용했다. </p><p>DCTP는 내가 만든 단어가 아니고  FRP를 만든 사람 중 한명인 <a href="https://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language" target="_blank" rel="noopener">Conal Elliott가 정의한 FRP</a>에서 나오는 내용이다. (링크한 페이지의 첫번째 댓글이다. 영문이지만 시간에 여유가 있다면 한번 읽어보기를 추천한다. 나도 저분처럼 백발의 능력있는 프로그래머가 되는 것이 꿈이다.)</p><p> 영어 실력이 부족하지만 일부분을 내 나름대로 재 번역(오역과 의역)하자면 아래와 같다.</p><!-- 나에게 FRP는 항상 두 가지로 요약 됩니다. a. 표시할수 있고(denotative), b. 시간에 연속적(temporally continuous)입니다. ….. "denotative, continuous-time programming" (DCTP)으로 FRP를 대체 하려고 합니다. 표시할 수 있는것은 각각의 타입과 구성요소의 의미를 정확히 지정해주는것으로 엄밀하고 단순하며 구현과 무관하여 의미론적으로 합성 가능한 것입니다. 각 구성요소를 합성한 것 중에서 타입이 올바른 것들은 모두 다 그 의미론에 따라서 정확한 의미를 결정 할 수 있습니다. Denotation Semantics는 프로그래밍 언어의 엄밀한 의미를 수학식을 사용해 정의한 것입니다. 수학식을 따르기 때문에 합성성(Compositionality)이라는 특성이 성립할 수 있는것을 증명해 줍니다.--><p>[주1: 표시적 의미론(Denotation Semantics)은 프로그래밍 언어의 의미를 수학식을 사용해 정의한 것이다.]</p><p>[주2: 표시적이라는(Denotative) 것은 각각의 타입과 구성요소의 의미를 정확히 지정해주는것이다. 구성요소는 단순하며 엄격하게 수학식을 따르기 때문에 합성성(Compositionality)이라는 특성을 가지고 있다. 이 뜻은 구현하지 않아도 의미론적으로 합성 가능하다는 것을 뜻한다. 각 구성요소를 합성한 것 중에서 타입이 올바른 것들은 모두 다 그 의미론적으로 정확한 의미를 결정 할 수 있습니다.]</p><p>[주3: <a href="http://conal.net/blog/posts/why-program-with-continuous-time" target="_blank" rel="noopener">시간에 연속적(Continuous Time/temporally continuous)</a>이라는 것은 시간이 지남에 따라 사용할 수 있게 되는 일련의 정렬 된 구성요소(데이터 요소)를 가르키는 것이다.]</p><h2 id="번외편-2-Rx-Operator"><a href="#번외편-2-Rx-Operator" class="headerlink" title="[번외편 2 - Rx Operator]"></a>[번외편 2 - Rx Operator]</h2><h3 id="Filtering-Operators"><a href="#Filtering-Operators" class="headerlink" title="Filtering Operators"></a>Filtering Operators</h3><h4 id="Ignore-operators"><a href="#Ignore-operators" class="headerlink" title="Ignore operators"></a>Ignore operators</h4><p>.ignoreElements() : onNext로 넘어오는 element 무시. onError()나 onComplated() 이벤트는 받는다</p><p>.elementAt(4) : 지정 된 숫자 이후의 onNext이벤트를 받는다</p><p>.filter { $0 &lt; 7 } : 필터 조건에 맞는 onNext이벤트만 통과 한다</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strikes = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> bag = <span class="type">DisposeBag</span>()</span><br><span class="line">    strikes</span><br><span class="line">        .elementAt(<span class="number">2</span>)</span><br><span class="line">        .subscribe(onNext: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"You're out!"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .disposed(by: bag)</span><br></pre></td></tr></table></figure><h4 id="Skipping-operators"><a href="#Skipping-operators" class="headerlink" title="Skipping operators"></a>Skipping operators</h4><p>.skip(2) : 주어진 숫자 이후의 onNext이벤트를 받는다</p><p>.skipWhile { $0 % 2 == 1 } : 지정 된 조건 될 때가지 모두 skip한다</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bag = <span class="type">DisposeBag</span>()</span><br><span class="line">    <span class="type">Observable</span>.of(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">        .skipWhile &#123; integer <span class="keyword">in</span></span><br><span class="line">            integer % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe(onNext: &#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .disposed(by: bag)</span><br></pre></td></tr></table></figure><h4 id="Taking-operators"><a href="#Taking-operators" class="headerlink" title="Taking operators"></a>Taking operators</h4><p>.take(3): skip과 반대이다. 지정 된 요소까지 이벤트를 받는다.</p><p>.takeWhileWithIndex : 인덱스와 값이 주어지고 그 조건에 따라서 이벤트를 필터해서 받는다</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>)</span><br><span class="line">    .takeWhileWithIndex &#123; integer, index <span class="keyword">in</span></span><br><span class="line">        integer % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; index &lt; <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: bag)</span><br></pre></td></tr></table></figure><h4 id="Distinct-operator"><a href="#Distinct-operator" class="headerlink" title="Distinct operator"></a>Distinct operator</h4><p>.distinctUntilChanged : 이전 값이 같은 값이면 무시한다</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>.of(<span class="string">"A"</span>, <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>)</span><br><span class="line">    .distinctUntilChanged()</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: bag)</span><br></pre></td></tr></table></figure><h4 id="Trigger-operators"><a href="#Trigger-operators" class="headerlink" title="Trigger operators"></a>Trigger operators</h4><p>위에 까지는 지정되거나 정적인 조건에 의해 실행 되었다.</p><p>아래는 다른 observable에 의해 다이나믹하게 실행 될 수 있는 operator에 대한 것이다.</p><p>.skipUntil :  다른 Observable의 이벤트가 오기 전에는 모두 건너 뛴다.</p><p>.takeUntil : 다른 Observable의 이벤트가 오기 전에는 모두 받는다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> subject = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> trigger = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">subject.takeUntil(trigger)</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: bag)</span><br></pre></td></tr></table></figure><h3 id="Transforming-elements"><a href="#Transforming-elements" class="headerlink" title="Transforming elements"></a>Transforming elements</h3><p>.toArray : 개별적인 Observable의 elements를 모아서 배열로 처리하는 방법 (Observable은 개별적으로 elements를 보냅니다)</p><p>.map : Observable에 동작하는 swift map</p><p>.mapWithIndex : 클로저에 index를 전달해주는 map</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    .mapWithIndex &#123; integer, index <span class="keyword">in</span></span><br><span class="line">        index &gt; <span class="number">2</span> ? integer * <span class="number">2</span> : integer</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: bag)</span><br></pre></td></tr></table></figure><h3 id="Transforming-inner-observables"><a href="#Transforming-inner-observables" class="headerlink" title="Transforming inner observables"></a>Transforming inner observables</h3><p>.flatMap : 내부에 각각 요소(Observable)를 가져 올 수 있다. swift flatmap과 동일 : [[T],[U]] -&gt; [T, U]와 같이..</p><p>.flatMapLatest : map + switchLatest </p><p>.switchLatest : Observable이 변경 되면 가장 최근 항목의 값만 받고 이전은 무시한다</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flatMap</span></span><br><span class="line"><span class="keyword">let</span> bag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> ryan = <span class="type">Student</span>(score: <span class="type">Variable</span>(<span class="number">80</span>))</span><br><span class="line"><span class="keyword">let</span> charlotte = <span class="type">Student</span>(score: <span class="type">Variable</span>(<span class="number">90</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> score: <span class="type">Variable</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> student = <span class="type">PublishSubject</span>&lt;<span class="type">Student</span>&gt;()</span><br><span class="line">student.asObservable()</span><br><span class="line">    .flatMap &#123; $<span class="number">0</span>.score.asObservable() &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br><span class="line">    .disposed(by: bag)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SwitchLatest</span></span><br><span class="line"><span class="keyword">let</span> one = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> two = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> three = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> source = <span class="type">PublishSubject</span>&lt;<span class="type">Observable</span>&lt;<span class="type">String</span>&gt;&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observable = source.switchLatest()</span><br><span class="line"><span class="keyword">let</span> disposable = observable.subscribe(onNext: &#123; value <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">&#125;)</span><br><span class="line">source.onNext(one)</span><br><span class="line">one.onNext(<span class="string">"Some text from sequence one"</span>)</span><br><span class="line">two.onNext(<span class="string">"Some text from sequence two"</span>)</span><br><span class="line">source.onNext(two)</span><br><span class="line">two.onNext(<span class="string">"More text from sequence two"</span>)</span><br><span class="line">one.onNext(<span class="string">"and also from sequence one"</span>)</span><br><span class="line">source.onNext(three)</span><br><span class="line">two.onNext(<span class="string">"Why don't you seem me?"</span>)</span><br><span class="line">one.onNext(<span class="string">"I'm alone, help me"</span>)</span><br><span class="line">three.onNext(<span class="string">"Hey it's three. I win."</span>)</span><br><span class="line">source.onNext(one)</span><br><span class="line">one.onNext(<span class="string">"Nope. It's me, one!"</span>)</span><br><span class="line">disposable.dispose()</span><br></pre></td></tr></table></figure><p>​    </p><h3 id="Combining-Operators"><a href="#Combining-Operators" class="headerlink" title="Combining Operators"></a>Combining Operators</h3><p>.concat : Observables을 취합하여 돌려준다. 첫번째 sequence가 다 끝나고 나서 다음 요소가 실행 된다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> second = <span class="type">Observable</span>.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">let</span> observable = <span class="type">Observable</span>.concat([first, second])</span><br><span class="line"></span><br><span class="line">  observable.subscribe(onNext: &#123; value <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><h4 id="대망의-MERGING"><a href="#대망의-MERGING" class="headerlink" title="대망의 MERGING!!"></a>대망의 MERGING!!</h4><p>.merging : Rx에서 Sequence를 결합하는 대표적인 방법. 병합. 이름 처럼 한다 ㅋㅋㅋ</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">left</span> = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">right</span> = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> source = <span class="type">Observable</span>.of(<span class="keyword">left</span>.asObservable(), <span class="keyword">right</span>.asObservable())</span><br><span class="line"><span class="keyword">let</span> observable = source.merge()</span><br><span class="line"><span class="keyword">let</span> disposable = observable.subscribe(onNext: &#123; value <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> leftValues = [<span class="string">"Berlin"</span>, <span class="string">"Munich"</span>, <span class="string">"Frankfurt"</span>]</span><br><span class="line"><span class="keyword">var</span> rightValues = [<span class="string">"Madrid"</span>, <span class="string">"Barcelona"</span>, <span class="string">"Valencia"</span>]</span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> arc4random_uniform(<span class="number">2</span>) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !leftValues.isEmpty &#123;</span><br><span class="line">      <span class="keyword">left</span>.onNext(<span class="string">"Left:  "</span> + leftValues.removeFirst())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> !rightValues.isEmpty &#123;</span><br><span class="line">    <span class="keyword">right</span>.onNext(<span class="string">"Right: "</span> + rightValues.removeFirst())</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> !leftValues.isEmpty || !rightValues.isEmpty</span><br><span class="line">disposable.dispose()</span><br></pre></td></tr></table></figure><p>추가 설명을 하자면 </p><p>merge()는 병합한 observable을 구독하고 그 안에서 오는 emits을 받고 있는데 누가 먼저 오고 나중에 오는 순서는 정해진게 없이 도착하는게 먼저다.</p><p>또한 Complate()에 대해 설명하자면</p><ol><li>source sequence가 완료 된 후에 그 안에 있는 sequence가 다 완료 되면 Compleate()를 보낸다</li><li>내부에 있는것의 완료 순서는 관계가 없다</li><li>sequence중 하나라도 error가 발생하면 바로 error() 이벤트를 보낸다.</li></ol><p>subscribe가 너무 많아서 제한을 하려면 </p><p>.merge(maxConcurrent:) 을 사용하면 된다.</p><p>.combineLatest : 시퀀스를 결합시킨다. 결합 된 내부의 swquence에서 이벤트가 발생하면 내부의 각 각 observable의 마지막 상태 값을 받는다. 보통 로그인에 많이 사용되며 TextField 2개를 걸어 두면 보통 두개의 Text값이 (마지막 상태) 넘어온다.</p><p>.zip : combineLatest와 같은 결합용이다. 차이점은 둘중 하나라도 종료되면 zip도 종료된다.</p><h4 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h4><p>.withLatestFrom : Observable을 이벤트를 통해 그 다른 observable의 마지막 값을 가져 온 다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="type">PublishSubject</span>&lt;<span class="type">Void</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> textField = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> observable = button.withLatestFrom(textField)</span><br><span class="line">    <span class="keyword">let</span> disposable = observable.subscribe(onNext: &#123; value <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;)</span><br><span class="line">    textField.onNext(<span class="string">"Par"</span>)</span><br><span class="line">    textField.onNext(<span class="string">"Pari"</span>)</span><br><span class="line">    textField.onNext(<span class="string">"Paris"</span>)</span><br><span class="line">    button.onNext()</span><br><span class="line">    button.onNext()</span><br></pre></td></tr></table></figure><h4 id="Switches"><a href="#Switches" class="headerlink" title="Switches"></a>Switches</h4><p>.amd(_:) : 교환 함. 2개의 이벤트를 동시에 보내면 교환 된 쪽으로만 이벤트 구독이 됨     [“amb = “ambiguous”]</p><p>.switchLatest : 교환 함.  런타임에 자기가 구독하고 싶은것을 선택 할 수 있음.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> one = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> two = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> three = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> source = <span class="type">PublishSubject</span>&lt;<span class="type">Observable</span>&lt;<span class="type">String</span>&gt;&gt;()</span><br><span class="line"><span class="keyword">let</span> observable = source.switchLatest()</span><br><span class="line"><span class="keyword">let</span> disposable = observable.subscribe(onNext: &#123; value <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(value)</span><br><span class="line">&#125;)</span><br><span class="line">source.onNext(one)</span><br><span class="line">one.onNext(<span class="string">"Some text from sequence one"</span>)</span><br><span class="line">two.onNext(<span class="string">"Some text from sequence two"</span>)</span><br><span class="line">source.onNext(two)</span><br><span class="line">two.onNext(<span class="string">"More text from sequence two"</span>)</span><br><span class="line">one.onNext(<span class="string">"and also from sequence one"</span>)</span><br><span class="line">source.onNext(three)</span><br><span class="line">two.onNext(<span class="string">"Why don't you seem me?"</span>)</span><br><span class="line">one.onNext(<span class="string">"I'm alone, help me"</span>)</span><br><span class="line">three.onNext(<span class="string">"Hey it's three. I win."</span>)</span><br><span class="line">source.onNext(one)</span><br><span class="line">one.onNext(<span class="string">"Nope. It's me, one!"</span>)</span><br><span class="line">disposable.dispose()</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Output</span> : switchLatest ---</span><br><span class="line"><span class="type">Some</span> text from sequence one</span><br><span class="line"><span class="type">More</span> text from sequence two</span><br><span class="line"><span class="type">Hey</span> it's three. <span class="type">I</span> win.</span><br><span class="line"></span><br><span class="line"><span class="type">Nope</span>. <span class="type">It's</span> me, one!</span><br></pre></td></tr></table></figure><p>.scan(_:accumulator:) : swift에서 reduce와 같은 기능을 Observable에게다 함. 뒤쪽 클로저의 조건에 의해 누적 된 누적합계 값을 보냄. 보통 클로저에 누적 합계, 통계, 상태 같은 조건을 넣음</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> source = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line"><span class="keyword">let</span> observable = source.scan(<span class="number">0</span>, accumulator: +)</span><br><span class="line">  observable.subscribe(onNext: &#123; value <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">     <span class="keyword">self</span>?.tableView.reloadData()</span><br><span class="line">     <span class="keyword">self</span>?.refreshControl?.endRefreshing()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="특별-정보-weak-unowerned-언제써야-하나"><a href="#특별-정보-weak-unowerned-언제써야-하나" class="headerlink" title="특별 정보 - weak? unowerned? 언제써야 하나"></a>특별 정보 - weak? unowerned? 언제써야 하나</h3><p>RxSwift나 RxCocoa를 사용 할 때 weak와 unowerned를 언제써야 하는지 이해하기 어려울 때가 있다.</p><p>weak는 현재의 self 오브젝트가 이미 released되었을 때에 어떤 시점에서 closure를 호출 해야 하는 상황에 사용한다.</p><p>(closure가 escape 상태로 생성 되어서 나중에 dhlqndptj closure를 호출 하는 경우를 말한다 - escape nonescape의 차이에 대해 알아야 한다)</p><p>unowerned는 optional self상태를 피해기 위해 사용한다. (중복 release) 예를 들면 같은 self를 closure에서 호출 후 에 release되어 버리면 closure를 가지고 있던 self가 optional상태가 되어서(정확히는 값이 해체 됨) app이 죽는다. </p><p>정리하면</p><p>nothing : 싱글톤 안에서는 안함,  release되지 않는 viewController에서는 안함(rootViewController 또는 window)</p><p>unowerned : escape closure를 가지고 있는 ViewController에서 Closure 호출 시 사용. 정확히는 ViewController가 release된 후에 closure task가 실행 되는 경우</p><p>weak : 다른 모든 경우에 사용</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;프로그래머를-위한-간결한-코드-작성-가이드&quot;&gt;&lt;a href=&quot;#프로그래머를-위한-간결한-코드-작성-가이드&quot; class=&quot;headerlink&quot; title=&quot;프로그래머를 위한 간결한 코드 작성 가이드&quot;&gt;&lt;/a&gt;프로그래머를 위한 간결한 코드 
      
    
    </summary>
    
    
  </entry>
  
</feed>
